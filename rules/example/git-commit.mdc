---
description: Enforce state-of-the-art git commit message principles with strict quality standards, pre-commit hook enforcement, and professional tone requirements
globs: ["**/.git/*", "**/.gitcommit*", "**/COMMIT_EDITMSG"]
---

# Git Commit Message Standards

@context {
    "type": "guidelines",
    "purpose": "git_commit_quality",
    "format_version": "1.0.0"
}

@rules [
    {
        "id": "commit-message-quality",
        "category": "git-standards",
        "severity": "error",
        "description": "Apply state-of-the-art git commit message principles"
    },
    {
        "id": "no-bypass-hooks",
        "category": "git-standards",
        "severity": "error",
        "description": "Strictly prohibit bypassing pre-commit hooks"
    },
    {
        "id": "no-emojis-in-commits",
        "category": "git-standards",
        "severity": "error",
        "description": "Completely disallow emojis in commit messages"
    },
    {
        "id": "professional-tone",
        "category": "git-standards",
        "severity": "error",
        "description": "Maintain factual, objective language without exaggeration"
    },
    {
        "id": "no-bulk-git-add",
        "category": "git-standards",
        "severity": "error",
        "description": "Prohibit git add -A and git add . commands"
    },
    {
        "id": "atomic-commits",
        "category": "git-standards",
        "severity": "error",
        "description": "Enforce atomic commits with single, logical changes"
    }
]

## Commit Message Quality Standards

@commit_message_structure {
    "subject_line": {
        "max_length": 50,
        "recommended_length": "50 characters or less",
        "mood": "imperative",
        "capitalization": "First letter capitalized",
        "punctuation": "No period at the end",
        "examples": [
            "Add user authentication feature",
            "Fix memory leak in data processor",
            "Refactor database connection logic"
        ]
    },
    "body": {
        "separation": "Blank line between subject and body",
        "line_wrap": 72,
        "focus": "What and why, not how",
        "tone": "Factual and objective"
    }
}

### Subject Line Requirements

@subject_line_rules {
    "imperative_mood": {
        "rule": "Use imperative mood (command form)",
        "correct": ["Add", "Fix", "Update", "Remove", "Refactor"],
        "incorrect": ["Added", "Fixed", "Updated", "Removed", "Refactored", "Adding", "Fixing"]
    },
    "length": {
        "hard_limit": 72,
        "recommended": 50,
        "rationale": "Ensures readability in git log and GitHub UI"
    },
    "clarity": {
        "rule": "Clear and concise description of the change",
        "avoid": ["vague terms", "unnecessary words", "implementation details"]
    }
}

### Body Text Requirements

@body_rules {
    "wrapping": {
        "max_line_length": 72,
        "rationale": "Ensures readability in various git tools and terminals"
    },
    "content_focus": {
        "what": "Describe what changed",
        "why": "Explain why the change was necessary",
        "not_how": "Avoid describing implementation details (code shows how)"
    },
    "separation": {
        "rule": "Always separate subject from body with a blank line",
        "rationale": "Required for proper parsing by git tools"
    }
}

## Pre-commit Hook Enforcement

@hook_enforcement {
    "id": "no-bypass-hooks",
    "severity": "error",
    "rationale": "Pre-commit hooks ensure code quality, security, and consistency"
}

### Strictly Prohibited

Never use the following flags when committing:
- `--no-verify` flag
- `-n` flag
- Any other mechanism to bypass pre-commit hooks

@prohibited_commands [
    "git commit --no-verify",
    "git commit -n",
    "git commit -m 'message' --no-verify",
    "git commit -m 'message' -n"
]

Pre-commit hooks exist for important reasons:
- Code quality checks (linting, formatting)
- Security scanning
- Test execution
- Commit message validation
- File size limits
- Sensitive data detection

## Staging Changes: Explicit File Addition

@staging_rules {
    "id": "no-bulk-git-add",
    "severity": "error",
    "rationale": "Explicit file staging ensures intentional, atomic commits and prevents accidental inclusion of unrelated changes"
}

### Strictly Prohibited

Never use the following commands when staging files:
- `git add -A`
- `git add .`
- `git add --all`

@prohibited_staging_commands [
    "git add -A",
    "git add .",
    "git add --all"
]

### Required Practice

Always explicitly add only the specific files that are directly related to the current change:

@required_staging_practice {
    "rule": "Use git add <filepath> for each file individually",
    "examples": [
        "git add src/auth/login.ts",
        "git add src/auth/login.test.ts",
        "git add docs/authentication.md"
    ],
    "rationale": [
        "Ensures you review each file being committed",
        "Prevents accidental inclusion of unrelated changes",
        "Supports atomic commit practice",
        "Makes it easier to create focused, logical commits"
    ]
}

If you need to add multiple files, add them one by one or list them explicitly:

```bash
# Good: Explicit individual files
git add src/auth/login.ts
git add src/auth/login.test.ts

# Good: Multiple files listed explicitly
git add src/auth/login.ts src/auth/login.test.ts

# Bad: Bulk staging
git add .
git add -A
```

## Atomic Commits

@atomic_commit_rules {
    "id": "atomic-commits",
    "severity": "error",
    "rationale": "Atomic commits improve code review, debugging, and version control history"
}

### Definition

Each commit must represent a single, logical change. An atomic commit is:
- **Self-contained**: Contains all changes needed for one specific purpose
- **Focused**: Addresses only one concern or feature
- **Functional**: Does not break the build when applied
- **Reversible**: Can be reverted without affecting unrelated functionality

@atomic_commit_principles {
    "single_logical_change": {
        "rule": "Each commit should contain only files that are part of one cohesive change",
        "examples": {
            "good": "All files related to implementing user login feature",
            "bad": "User login feature + unrelated bug fix in payment module"
        }
    },
    "related_changes_grouped": {
        "rule": "Related changes should be grouped together in a single commit",
        "examples": {
            "good": "Implementation file + test file + documentation for same feature",
            "bad": "Implementation in one commit, tests in another, docs in a third"
        }
    },
    "unrelated_changes_separated": {
        "rule": "Unrelated changes should be split into separate commits",
        "examples": {
            "good": "Commit 1: Fix login bug. Commit 2: Update README",
            "bad": "Single commit with both login bug fix and README update"
        }
    },
    "independently_functional": {
        "rule": "Each commit should be independently functional and not break the build",
        "rationale": "Enables bisecting, cherry-picking, and reverting without issues"
    }
}

### Guidelines for Atomic Commits

@atomic_commit_guidelines {
    "one_concern_per_commit": {
        "description": "Each commit addresses exactly one concern",
        "examples": {
            "good": [
                "Add user authentication",
                "Fix memory leak in worker",
                "Update dependencies to latest versions"
            ],
            "bad": [
                "Add authentication and fix memory leak",
                "Update dependencies and refactor database code"
            ]
        }
    },
    "complete_implementation": {
        "description": "Include all files needed for the change to work",
        "include": [
            "Source code changes",
            "Related test updates",
            "Configuration changes",
            "Documentation updates for the same feature"
        ]
    },
    "build_integrity": {
        "description": "Commit should not break the build",
        "verify": [
            "Code compiles successfully",
            "Tests pass",
            "No broken imports or references"
        ]
    }
}

### When to Split Commits

Split changes into multiple commits when:
- Fixing multiple unrelated bugs
- Implementing multiple independent features
- Refactoring code AND adding new features
- Updating dependencies AND making code changes
- Making changes to unrelated modules or components

@split_commit_examples {
    "scenario": "You fixed a bug in authentication and updated the README",
    "wrong": "Single commit with both changes",
    "correct": [
        "Commit 1: Fix null pointer exception in authentication",
        "Commit 2: Update README with new installation steps"
    ]
}

### When to Group Changes

Group changes in a single commit when:
- Implementation and its corresponding tests
- Code change and its related documentation
- Multiple files that together implement one feature
- Refactoring that affects multiple files for the same purpose

@group_commit_examples {
    "scenario": "You implemented a new user profile feature",
    "correct": "Single commit including:",
    "files": [
        "src/profile/profile.ts (implementation)",
        "src/profile/profile.test.ts (tests)",
        "docs/features/profile.md (documentation)"
    ],
    "rationale": "All files are part of the same logical change"
}

## Emoji Prohibition

@emoji_rules {
    "id": "no-emojis-in-commits",
    "severity": "error",
    "scope": "all_commit_messages",
    "rationale": "Emojis reduce professionalism, cause encoding issues, and hinder searchability"
}

Emojis are completely disallowed in:
- Subject lines
- Body text
- Commit footers
- Any part of the commit message

@examples_emoji {
    "bad": [
        "‚ú® Add new feature",
        "üêõ Fix bug in parser",
        "Add user profile üéâ",
        "Fix: üîß Update configuration"
    ],
    "good": [
        "Add new feature",
        "Fix bug in parser",
        "Add user profile",
        "Fix: Update configuration"
    ]
}

## Tone and Style Requirements

@tone_rules {
    "objectivity": {
        "rule": "Use factual, objective language",
        "avoid": ["subjective opinions", "emotional language", "exaggeration"]
    },
    "simplicity": {
        "rule": "Write in simple, straightforward sentences",
        "avoid": ["complex jargon", "unnecessary technical details", "verbose explanations"]
    },
    "neutrality": {
        "rule": "Maintain a neutral, professional tone",
        "avoid": ["marketing language", "hyperbole", "overstating impact"]
    }
}

### Language to Avoid

@prohibited_language [
    {
        "type": "exaggeration",
        "examples": ["amazing", "incredible", "revolutionary", "game-changing", "awesome"],
        "reason": "Overstates the impact of changes"
    },
    {
        "type": "marketing",
        "examples": ["best-in-class", "world-class", "cutting-edge", "next-generation"],
        "reason": "Inappropriate for technical commit messages"
    },
    {
        "type": "hyperbole",
        "examples": ["completely rewrote", "totally fixed", "massively improved"],
        "reason": "Exaggerates scope of changes"
    },
    {
        "type": "subjective",
        "examples": ["beautiful code", "elegant solution", "clever trick"],
        "reason": "Subjective opinions rather than factual descriptions"
    }
]

### Preferred Language

@preferred_language {
    "factual_verbs": [
        "Add", "Remove", "Fix", "Update", "Refactor",
        "Implement", "Change", "Modify", "Correct", "Adjust"
    ],
    "objective_descriptions": [
        "Improve performance by reducing database queries",
        "Fix null pointer exception in user service",
        "Update dependency to address security vulnerability",
        "Refactor authentication logic for better maintainability"
    ]
}

## Content Focus

@content_guidelines {
    "describe_changes": {
        "rule": "Describe actual changes made to the codebase",
        "focus": "What was changed and why it was necessary",
        "avoid": "How it was implemented (code shows this)"
    },
    "no_embellishment": {
        "rule": "State facts without embellishment",
        "examples": {
            "bad": "Dramatically improved the amazing user experience",
            "good": "Reduce page load time by optimizing image assets"
        }
    }
}

## Complete Examples

@examples {
    "bad": [
        {
            "description": "Uses past tense, emoji, and exaggeration",
            "commit": "üéâ Added amazing new feature that revolutionizes user experience!"
        },
        {
            "description": "Bypasses hooks and uses marketing language",
            "commit": "git commit -n -m 'Implement world-class authentication system'"
        },
        {
            "description": "Too long subject, no separation, subjective language",
            "commit": "This commit adds a really beautiful and elegant solution for handling user authentication\nThis is an incredible improvement to our codebase."
        },
        {
            "description": "Vague and uses emoji",
            "commit": "‚ú® Update stuff üöÄ"
        },
        {
            "description": "Uses bulk git add command",
            "workflow": "git add -A\ngit commit -m 'Add authentication feature'"
        },
        {
            "description": "Non-atomic commit with unrelated changes",
            "commit": "Add user authentication and fix typo in README\n\nImplement JWT authentication and also fix a spelling error\nin the README file."
        }
    ],
    "good": [
        {
            "description": "Proper imperative mood, clear, concise",
            "commit": "Add user authentication with JWT tokens\n\nImplement JWT-based authentication to replace session cookies.\nThis improves security and enables stateless authentication\nfor the API."
        },
        {
            "description": "Clear fix description with context",
            "commit": "Fix memory leak in background worker\n\nResolve issue where worker threads were not properly released\nafter task completion. This was causing memory usage to grow\nover time in production environments."
        },
        {
            "description": "Simple, factual refactoring",
            "commit": "Refactor database connection pooling\n\nExtract connection pool logic into separate module to improve\ncode organization and enable reuse across services."
        },
        {
            "description": "Concise subject-only commit for simple change",
            "commit": "Update README with installation instructions"
        },
        {
            "description": "Explicit file staging with atomic commit",
            "workflow": "git add src/auth/jwt.ts\ngit add src/auth/jwt.test.ts\ngit add docs/authentication.md\ngit commit -m 'Add JWT authentication'\n\n# Separate commit for unrelated change\ngit add README.md\ngit commit -m 'Fix typo in README'"
        },
        {
            "description": "Atomic commit with related files grouped",
            "workflow": "git add src/profile/profile.ts\ngit add src/profile/profile.test.ts\ngit add docs/features/profile.md\ngit commit -m 'Add user profile feature\n\nImplement user profile page with edit capabilities.\nIncludes profile component, tests, and documentation.'"
        }
    ]
}

## Validation Checklist

@validation_checklist [
    {
        "check": "Subject line uses imperative mood",
        "examples": "Add, Fix, Update (not Added, Fixed, Updated)"
    },
    {
        "check": "Subject line is 50 characters or less (72 hard limit)",
        "action": "Keep it concise and clear"
    },
    {
        "check": "Subject and body separated by blank line",
        "action": "Required if body text is present"
    },
    {
        "check": "Body lines wrapped at 72 characters",
        "action": "Ensure readability in all git tools"
    },
    {
        "check": "No emojis anywhere in commit message",
        "action": "Remove all emoji characters"
    },
    {
        "check": "No --no-verify or -n flags used",
        "action": "Never bypass pre-commit hooks"
    },
    {
        "check": "Language is factual and objective",
        "action": "Remove exaggeration, marketing terms, hyperbole"
    },
    {
        "check": "Describes what and why, not how",
        "action": "Focus on the change and its purpose"
    },
    {
        "check": "Files staged explicitly, not with git add -A or git add .",
        "action": "Use git add <filepath> for each file individually"
    },
    {
        "check": "Commit is atomic and contains only related changes",
        "action": "Split unrelated changes into separate commits"
    },
    {
        "check": "Commit does not break the build",
        "action": "Verify code compiles and tests pass"
    }
]

@version "1.0.0"
@last_updated "2025-11-14"

